%%% LABELING RULES %%%
% Add the token feature to all nodes (NOTE: this does not work, probably need to copy N and use in in another rule or ask the developer of grew)
rule add_token_init {
    pattern { N [ lemma, !token ]; }
    without { N -[temp]-> *; }
    commands { 
        add_node TEMP_NODE;
        TEMP_NODE.token = N.lemma;
        add_edge N -[temp]-> TEMP_NODE;
    }
}

rule add_token_final {
    pattern { 
        TEMP_NODE [ token ]; 
        N [ !token ]; 
        R: N -[temp]-> TEMP_NODE;
    }
    without { N [ token ]; }
    commands { 
        N.token = TEMP_NODE.token;
        del_node TEMP_NODE;
        del_edge R;
    }
}

%%% CONNECTING RULES %%%
% Piet lost his glasses: glasses -[User]-> Piet
rule connect_user {
    pattern {
        USER [ upos=PROPN|NOUN ]; 
        * -[nsubj|nsubj:pass]-> USER;
        REL: TARGET -[nmod:poss]-> INDICATOR;
    }
    without { TARGET -[User]-> USER; }
    commands {
        % add_edge USER -[Owner]-> TARGET;
        add_edge TARGET -[User]-> USER;
        del_edge REL;
        del_node INDICATOR;
    }
}

rule expand_name {
    pattern { NAME [ upos=PROPN ]; }
    without { NAME -> *; }
    commands {
        % NOTE assign proper label, maybe with combination of PROPN + Gender = Fem
        NAME.token = "entity.n.01";
        add_node NAME_CONST;
        NAME_CONST.token = NAME.lemma; % NOTE: dit zou token moeten zijn
        add_edge NAME -[Name]-> NAME_CONST;
    }
}

% A speaker is split up into 'person-sense' -[EQU]-> 'speaker', possible use Person=1 or other feats to indicate speaker or hearer
rule expand_speaker {
    pattern {
        SPEAKER [ upos=PRON ]; 
         * -[nsubj|nsubj:pass]-> SPEAKER;
    }
    without { SPEAKER -[EQU]-> *; }
    commands {
        SPEAKER.token = "person.n.01";
        add_node SPEAKER_CONST;
        SPEAKER_CONST.token = "speaker";
        add_edge SPEAKER -[EQU]-> SPEAKER_CONST;
    }
}

rule add_time {
    pattern { N []; * -[root]-> N; }
    without { N -[Time]-> *; }
    commands {
        add_node TIME_SENSE;
        % use lexicon here or apply mappings after rewrite rules
        TIME_SENSE.token = "time.n.08"; 
        add_edge N -[Time]-> TIME_SENSE;

        add_node TIME_CONST;
        % use lexicon here or apply mappings after rewrite rules
        TIME_CONST.token = "now"; 
        add_edge TIME_SENSE -[TPR]-> TIME_CONST;
    }
}

%%% COMBING RULES %%%
% Maybe combine NOUN -[amod]-> ADJ into single token, example: good- bye
% Maybe combine A -[xcomp]-> ADJ1 and A -[xcomp]-> ADJ2 (or more) into single token, example: bright blue
% nummod deprel kan vervangen worden door sense -[Quantity]-> number

% Combine multiple PROPN's that probably belong together. This is quite tricky since this is very
% vunrable to UD parse error or oddities (see example).
% Example: en/gold/p65/d1215
rule combine_propn {
    pattern { 
        A [ upos=PROPN ]; 
        B [ upos=PROPN ]; 
        R: A -[flat|compound]-> B;
    }
    commands {
        A.lemma = A.lemma + " " + B.lemma;
        del_edge R;
        del_node B;
    }
}

%%% CLEANING RULES %%%
% Remove any punctuation that is connected to the root directly.
% These are the sentence ending punctuation marks.
rule remove_root_punct { 
    pattern { 
        * -[root]-> ROOT; 
        E: ROOT -> N;
        N [ upos=PUNCT ];
    }
    commands {
        del_edge E;
        del_node N;
    }
}

rule remove_unwanted_pos { 
    pattern { 
        % Not sure about PART here since that can also indicate negation or possession, which is semantically useful
        % Same goes for CCONJ and SCONJ, for now they are removed, since they often also don't contribute anything
        % and are basically never used as a node on their own.
        N [ upos=PUNCT|DET|AUX|AUX_PASS|CASE|EXPL|ADP|PART|CCONJ|SCONJ ];
    }
    commands {
        del_node N;
    }
}

rule remove_explicit_root {
    pattern {
        N [];
        E: N -[root]-> T; 
    }
    commands {
        del_edge E;
        del_node N;
    }
}


%%% SPECIAL CASES %%%
% This can happen if a rule connects nodes together and later removes some.
% If for instance the Owner role gets added, this might introduce a cycle.
% This is a trade-off, there is information loss, but at least the output is
% guarenteed to be a valid DAG. Possibly deal with cases more specifically,
% though it is quite rare that this happens.
% Example: en/gold/p96/d1385 (caused by connect_user)
rule detach_cycles { 
    pattern { 
        N [];
        M [];
        A: N -> M;
        B: M -> N;
    }
    commands {
        del_edge B
    }
}

strat main {
    Pick(
        Iter (
            Seq (
                %Iter(add_token_init),
                %Iter(add_token_final),

                Iter(combine_propn),

                Iter(connect_user),
                Iter(expand_name),
                Iter(expand_speaker),
                Iter(add_time),
                Iter(remove_root_punct),
                Iter(remove_explicit_root),
                Iter(remove_unwanted_pos),

                Iter(detach_cycles),
            )
        )
    )
}